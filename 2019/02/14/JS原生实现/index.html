<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            JS原生实现过程
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            FBB
        </a>
    </h1>
    <h2>
        <a class="motto">
            think more, learn more !
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://luckyfbb.github.io/resume/" class="menu-item-link">
                        Resume
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/LuckyFBB/" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                
                
        </ul>
    </nav>
</header>
    <main class="main">
        <article class="post">
            <h1>
                <a class="title" href="/2019/02/14/JS原生实现/"> 
                    JS原生实现过程 
                </a>
            </h1>
            <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-02-14   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li></ul>
            </div>
<div class="toc">
  <ol class="toc-list"><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#new-操作符"><span class="toc-list-text">new 操作符</span></a></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#instanceof-操作符"><span class="toc-list-text">instanceof 操作符</span></a></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#call-apply-bind-的实现"><span class="toc-list-text">call / apply / bind 的实现</span></a></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#flat-的实现"><span class="toc-list-text">flat 的实现</span></a></li></ol><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#jsonp-的实现"><span class="toc-list-text">jsonp 的实现</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#函数柯里化"><span class="toc-list-text">函数柯里化</span></a></li></ol>
</li></div>
            <div class="content">
                <p>总结一下一些操作符或者方法的原生实现。持续更新<a id="more"></a></p>
<h4 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h4><p>创建某个实例，必须使用 new 操作符。这种方式调用构造函数会经历以下 4 个步骤:</p>
<ul>
<li>创造一个新的对象</li>
<li>将构造函数的作用域赋值给新对象(this 指向该对象)</li>
<li>执行构造函数中的代码(为新对象添加属性)</li>
<li>返回新对象</li>
</ul>
<pre><code class="js">function myNew(fun) {
  var obj = Object.create(fun.prototype);
  //var obj = {}
  //obj.__proto__ = fun.prototype  与上述方法实现效果相同
  var args = [...arguments].slice(1);
  var res = fun.call(obj, args);
  return typeof res === &quot;object&quot; ? res : obj;
}
</code></pre>
<h4 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h4><p>instanceof 可以正确的判断对象的类型，因为内部的机制是通过判断对象的原型链中是不是能够找到类型的 prototype。</p>
<pre><code class="js">function myInstanceof(left, right) {
  if (typeof left !== &quot;object&quot; || typeof left !== &quot;function&quot;) {
    return false;
  }
  let prototype = right.prototype;
  left = left.__proto__;
  while (true) {
    if (left === null) {
      return false;
    }
    if (prototype === left) {
      return true;
    }
    left = left.__proto__;
  }
}
</code></pre>
<h4 id="call-apply-bind-的实现"><a href="#call-apply-bind-的实现" class="headerlink" title="call / apply / bind 的实现"></a>call / apply / bind 的实现</h4><pre><code class="js">call  func.call(obj, args1, args2); //传入的是参数列表
apply func.apply(obj, [args1, args2]); //传入的是数组参数    记法：apply是a开头为array
bind  func.bind(obj, args1, args2); //返回的是函数，前两者为立即执行
</code></pre>
<p>思想</p>
<pre><code class="js">改变this的指向，让bar()函数的this指向foo对象
var foo = {
  value: 100
}
function bar() {
  console.log(this.value);
}
bar.apply(foo);

等同与将bar函数作为foo对象属性进行调用，即为下列方式
var foo = {
  value: 100
  bar: function() {
    console.log(this.value);
  }
}

因此我们总结模拟思路如下：
1.将执行的函数作为对象属性
2.执行函数
3.将函数从对象中删除
</code></pre>
<ul>
<li>call 的实现</li>
</ul>
<pre><code class="js">Function.prototype.myCall = function(context) {
  //使用该方式在原型链上拓展方法，以便所有的函数都能够使用.方式调用
  if (typeof this !== &quot;function&quot;) {
    //判断调用是否为函数
    throw new TypeError(&quot;Error&quot;);
  }
  const ctx = context || window; //取到传入的对象(执行上下文)，如果不传参数默认指向window
  ctx.func = this; //给obj对象添加一个func方法，this也就是调用myCall的函数
  const args = [...arguments].slice(1); //取得传入除了obj的参数
  const result = ctx.func(...args); //执行函数
  delete ctx.func; //删除函数
  return result;
};
</code></pre>
<ul>
<li>apply 的实现，只是和 call 传参上的实现不同</li>
</ul>
<pre><code class="js">Function.prototype.myApply = function(context) {
  if (typeof this !== &quot;function&quot;) {
    throw new TypeError(&quot;Error&quot;);
  }
  const ctx = context || window;
  ctx.func = this;
  let result;
  if (arguments[1]) {
    //判断是否传入数组参数,如果传入就要展开数组
    result = ctx.func(...arguments[1]);
  } else {
    result = ctx.func();
  }
  delete ctx.func;
  return result;
};
</code></pre>
<ul>
<li>bind 的实现<br>相对于前两个，这个函数返回的函数，并不是立即执行。</li>
</ul>
<pre><code class="js">Function.prototype.myBind = function(context) {
  if (typeof this !== &quot;function&quot;) {
    throw new TypeError(&quot;Error&quot;);
  }
  context = context || window;
  const _this = this;
  const args = [...arguments].slice(1);
  return function F() {
    return _this.apply(context, args.concat(...arguments));
  };
};
</code></pre>
<h4 id="flat-的实现"><a href="#flat-的实现" class="headerlink" title="flat 的实现"></a>flat 的实现</h4><p>ES6 中新增了 flat 方法，将多位数组变为低维数组。如果不传参数默认为一层，传参数可以规定展平的层级。</p>
<pre><code class="js">function isArray(arr) {
  return Array.isArray(arr);
}

function myFlat(arr) {
  var result = [];
  var deep = arguments[1] === undefined ? 1 : arguments[1]; //判断是否传入展平层级
  arr.forEach(element =&gt; {
    if (isArray(element) &amp;&amp; deep &gt;= 1) {
      result = result.concat(myFlat(element, deep - 1));
    } else {
      result.push(element);
    }
  });
  return result;
}
</code></pre>
<h3 id="jsonp-的实现"><a href="#jsonp-的实现" class="headerlink" title="jsonp 的实现"></a>jsonp 的实现</h3><p>jsonp 的作用是解决跨域问题。<br>因为 script 标签不受同源策略限制，所以可以动态插入 script 实现跨域。</p>
<pre><code class="js">function jsonp(url, data) {
  data = data || {};
  return new Promise((resovle, reject) =&gt; {
    const cbFn = `jsonp_${Date.now()}`;
    data.callback = cbFn;
    const head = document.querySelector(&quot;head&quot;);
    const script = document.createElement(&quot;script&quot;);
    const src = `${url}?${dataToUrl(data)}`;
    script.src = src;
    head.append(script);
    window[ncbFn] = res =&gt; {
      resovle(res);
      head.removeChild(script);
      window[cbFn] = null;
    };
  });
}

function dataToUrl(data) {
  return Object.keys(data)
    .reduce((pre, curr) =&gt; {
      pre.push(`${curr}=${data[curr]}`);
      return pre;
    }, [])
    .join(&quot;&amp;&quot;);
}

jsonp(&quot;http://jsonplaceholder.typicode.com/comments&quot;, {
  postId: 1
}).then(res =&gt; {
  console.log(res);
});
</code></pre>
<h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>当某个函数一次需要接受多个参数时，可以使用柯里化来使得当前函数一次性接受少一点的参数。</p>
<p>百科：把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
<pre><code class="js">function carry(fn) {
  const args = [...arguments].slice(1);
  if (fn.length &lt;= args.length) {
    //当传入参数的数量&gt;=函数参数数量时，执行函数
    return fn(...args);
  }
  return function() {
    //返回一个函数，等待传入其他参数
    const args1 = [...arguments];
    return carry(fn, ...args, ...args1);
  };
}

function add(a, b, c) {
  return a + b + c;
}

const carryAdd = carry(add);

carryAdd(1, 2, 3);
carryAdd(1)(2, 3);
carryAdd(1)(2)(3);
carryAdd(1)()(2)()(3);
</code></pre>

            </div>
          
           
            <div class="copyright">
                <div class="name">
                    <a>本文作者:</a>
                    <a>LuckyFBB</a>
                </div>
                <div class="link">
                    <a>本文链接:</a>
                    <a class="permalink" href="http://yoursite.com/2019/02/14/JS原生实现/">http://yoursite.com/2019/02/14/JS原生实现/</a>
                </div>
            </div>
            

          


</article>


<div class="more">

    <div class="prev">
   <a href="/2019/03/05/今日份感想/">  今日份感想</a>
    </div>

<div></div>

    <div class="next">
    <a href="/2019/02/13/垂直居中/"> 如何实现元素居中 </a>
    </div>
    
</div>

<div class="bdsharebuttonbox">
<!-- <a href="#" class="bds_weixin fa fa-weixin" data-cmd="weixin" title="分享到微信" style="color:#1cbd8f">
</a>
<a href="#" class="bds_tsina fa fa-weibo" data-cmd="tsina" title="分享到新浪微博" style="color:#ff6363">
</a>
<a href="#" class="bds_twi fa fa-twitter" data-cmd="twi" title="分享到Twitter" style="color:#00A7EB">
</a>
<a href="#" class="bds_fbook fa fa-facebook" data-cmd="fbook" title="分享到Facebook" style="color:#00A7EB">
</a>
</div> -->
<script>
window._bd_share_config={
    "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},
    "share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='../../../../../static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script>
 
<!-- <div id="comments"></div>

<script>
    var gitment = new Gitment({
    id: "Thu Feb 14 2019 09:38:50 GMT+0800",
    owner: "LuckyFBB",
    repo: "LuckyFBB.github.io",
    oauth: {
      client_id:"8d83609a651e972e308d",
      client_secret: "37e40c89a47e957f654e86f71c5caaccad0774de",
    }
  })
  gitment.render('comments')
</script> -->
    </div></main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2019 blog by LuckyFBB
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>