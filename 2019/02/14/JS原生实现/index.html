<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
      <script>
  var _hmt = _hmt || []
  ;(function() {
    var hm = document.createElement('script')
    hm.src = 'https://hm.baidu.com/hm.js?5a0acc897fd96474a2c8f4deac84611a'
    var s = document.getElementsByTagName('script')[0]
    s.parentNode.insertBefore(hm, s)
  })()
</script> 
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="LuckyFBB, 前端, 博客, 基础总结, JavaScript, FBB">
    <meta name="description" content="FBB针对某些问题，对于前端基础的总结，所生成的博客">
    
    <title>
      JS原生实现过程 - 路漫漫其修远兮
    </title>
    <link rel="manifest" href="/manifest.json">
    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/style/style.css">
  </head>
  <body>
    
    <div id="post-toc" class="animated hiddenToc hide">
      <span class="title">Toc</span>
      <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#new-操作符"><span class="toc-text">new 操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof-操作符"><span class="toc-text">instanceof 操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call-apply-bind-的实现"><span class="toc-text">call / apply / bind 的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flat-的实现"><span class="toc-text">flat 的实现</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#防抖-节流"><span class="toc-text">防抖 / 节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsonp-的实现"><span class="toc-text">jsonp 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数柯里化"><span class="toc-text">函数柯里化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LazyMan-链式调用"><span class="toc-text">LazyMan(链式调用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组去重"><span class="toc-text">数组去重</span></a></li></ol>
    </li></div>
    
    <div id="fixed-menu-wrap">
      <span style="background:#fff"></span>
      <!-- <span class="iconfont icon-sousuo search-box menu-reset"></span> -->
      <span class="icon-toc menu-reset">Toc</span>
      <span class="iconfont icon-arrowup menu-reset"></span>
    </div>
    <div id="fixed-menu">
      <span class="iconfont icon-menu-"></span>
    </div>
    <div id="progress">
      <div class="line"></div>
    </div>
    <div id="search-shade" class="animated hiddenSearch hide">
      <div class="input-wrap">
        <span class="iconfont icon-sousuo search-box"></span>
        <input type="text" placeholder="Search">
        <span class="iconfont icon-close"></span>
      </div>
      <div class="search-result">
        <div class="meta">
          <span><b id="result-count">0</b> results found</span>
          <img src="/images/logo.jpg">
        </div>
        <ul id="result-box"></ul>
      </div>
    </div>
    <div id="menu-mask" class="animated hideMenuMask hide">
      <span class="iconfont icon-close"></span>
      <div class="nav">
        
        <a href="/" class>
          首页
        </a>
        
        <a href="/archives" class>
          归档
        </a>
        
        <a href="/categories" class>
          分类
        </a>
        
        <a href="/tags" class>
          标签
        </a>
        
      </div>
    </div>
    <div id="header">
      <div class="intro">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpg')"></a>
        <div class="author">FBB</div>
      </div>
      <div class="nav">
        <span class="iconfont icon-menu menu-icon"></span>
        <!-- <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a> -->
      </div>
    </div>
    <div id="side" class="animated bounceInLeft">
      <div class="shrink">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpg')"></a>
        <span class="iconfont icon-menu toggle-icon"></span>
        <!-- <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a> -->
      </div>
      <div class="magnify">
        <div class="about">
          <div class="author">FBB</div>
          <a href="/" class="logo" style="background-image: url('/images/logo.jpg')"></a>
        </div>

        <div class="nav">
          
          <a href="/" class>
            首页
          </a>
          
          <a href="/archives" class>
            归档
          </a>
          
          <a href="/categories" class>
            分类
          </a>
          
          <a href="/tags" class>
            标签
          </a>
          
          <!-- <a href="#" class="search-box">
            <span class="iconfont icon-sousuo"></span>
          </a> -->
        </div>
        <div class="bottom">
          <div class="follow">
            
            <a href="https://github.com/LuckyFBB/" target="_block">
              <span class="iconfont icon-github"></span>
            </a>
             
          </div>
        </div>
      </div>
    </div>
    <div id="container">
      <div class="main animated bounceInRight delay-0.7s">
        <article class="post-entry">
    <div class="header">
      
      <div class="title">JS原生实现过程</div>
      <div class="meta">
        <span class="item">
          <span class="iconfont icon-time-circle"></span>
          <span>2019/02/14</span>
        </span>

        

         
        <span class="item">
          <span class="iconfont icon-folder"></span>
          <span>
              
                
                  <a href="/categories/前端">前端</a>
                
              
          </span>
        </span>
        
        
         
          <span class="item">
            <span class="iconfont icon-tag1"></span>
            <span>
                
                  
                    <a href="/tags/JS">JS</a>
                  
                
            </span>
          </span>
         
      </div>
      <div>
      </div>
    </div>
    <p>总结一下一些操作符或者方法的原生实现。持续更新<a id="more"></a></p>
<h4 id="new-操作符">new 操作符<a class="post-anchor" href="#new-操作符"></a></h4><p>创建某个实例，必须使用 new 操作符。这种方式调用构造函数会经历以下 4 个步骤:</p>
<ul>
<li>创造一个新的对象</li>
<li>将构造函数的作用域赋值给新对象(this 指向该对象)</li>
<li>执行构造函数中的代码(为新对象添加属性)</li>
<li>返回新对象</li>
</ul>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">fun</span>) </span>&#123;
  <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(fun.prototype);
  <span class="hljs-comment">//var obj = &#123;&#125;</span>
  <span class="hljs-comment">//obj.__proto__ = fun.prototype  与上述方法实现效果相同</span>
  <span class="hljs-keyword">var</span> args = [...arguments].slice(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">var</span> res = fun.call(obj, args);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">"object"</span> ? res : obj;
&#125;</code></pre>
<h4 id="instanceof-操作符">instanceof 操作符<a class="post-anchor" href="#instanceof-操作符"></a></h4><p>instanceof 可以正确的判断对象的类型，因为内部的机制是通过判断对象的原型链中是不是能够找到类型的 prototype。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> left !== <span class="hljs-string">"object"</span> || <span class="hljs-keyword">typeof</span> left !== <span class="hljs-string">"function"</span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;
  <span class="hljs-keyword">let</span> prototype = right.prototype;
  left = left.__proto__;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
    <span class="hljs-keyword">if</span> (left === <span class="hljs-literal">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-keyword">if</span> (prototype === left) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
    left = left.__proto__;
  &#125;
&#125;</code></pre>
<h4 id="call-apply-bind-的实现">call / apply / bind 的实现<a class="post-anchor" href="#call-apply-bind-的实现"></a></h4><pre><code class="hljs js">call  func.call(obj, args1, args2); <span class="hljs-comment">//传入的是参数列表</span>
apply func.apply(obj, [args1, args2]); <span class="hljs-comment">//传入的是数组参数    记法：apply是a开头为array</span>
bind  func.bind(obj, args1, args2); <span class="hljs-comment">//返回的是函数，前两者为立即执行</span></code></pre>
<ul>
<li>中心思想</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// 改变this的指向，让bar()函数的this指向foo对象</span>
<span class="hljs-keyword">var</span> foo = &#123;
  <span class="hljs-attr">value</span>: <span class="hljs-number">100</span>
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.value);
&#125;
bar.apply(foo);

<span class="hljs-comment">//等同与将bar函数作为foo对象属性进行调用，即为下列方式</span>
<span class="hljs-keyword">var</span> foo = &#123;
  <span class="hljs-attr">value</span>: <span class="hljs-number">100</span>
  <span class="hljs-attr">bar</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.value);
  &#125;
&#125;

<span class="hljs-comment">/*
 * 因此我们总结模拟思路如下：
 * 1.将执行的函数作为对象属性
 * 2.执行函数
 * 3.将函数从对象中删除
*/</span></code></pre>
<ul>
<li>call 的实现</li>
</ul>
<pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;
  <span class="hljs-comment">//使用该方式在原型链上拓展方法，以便所有的函数都能够使用.方式调用</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) &#123;
    <span class="hljs-comment">//判断调用是否为函数</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Error"</span>);
  &#125;
  <span class="hljs-keyword">const</span> ctx = context || <span class="hljs-built_in">window</span>; <span class="hljs-comment">//取到传入的对象(执行上下文)，如果不传参数默认指向window</span>
  ctx.func = <span class="hljs-keyword">this</span>; <span class="hljs-comment">//给obj对象添加一个func方法，this也就是调用myCall的函数</span>
  <span class="hljs-keyword">const</span> args = [...arguments].slice(<span class="hljs-number">1</span>); <span class="hljs-comment">//取得传入除了obj的参数</span>
  <span class="hljs-keyword">const</span> result = ctx.func(...args); <span class="hljs-comment">//执行函数</span>
  <span class="hljs-keyword">delete</span> ctx.func; <span class="hljs-comment">//删除函数</span>
  <span class="hljs-keyword">return</span> result;
&#125;;</code></pre>
<ul>
<li>apply 的实现，只是和 call 传参上的实现不同</li>
</ul>
<pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Error"</span>);
  &#125;
  <span class="hljs-keyword">const</span> ctx = context || <span class="hljs-built_in">window</span>;
  ctx.func = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">let</span> result;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]) &#123;
    <span class="hljs-comment">//判断是否传入数组参数,如果传入就要展开数组</span>
    result = ctx.func(...arguments[<span class="hljs-number">1</span>]);
  &#125; <span class="hljs-keyword">else</span> &#123;
    result = ctx.func();
  &#125;
  <span class="hljs-keyword">delete</span> ctx.func;
  <span class="hljs-keyword">return</span> result;
&#125;;</code></pre>
<ul>
<li>bind 的实现<br>相对于前两个，这个函数返回的函数，并不是立即执行。</li>
</ul>
<pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Error"</span>);
  &#125;
  context = context || <span class="hljs-built_in">window</span>;
  <span class="hljs-keyword">const</span> _this = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">const</span> args = [...arguments].slice(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> _this.apply(context, args.concat(...arguments));
  &#125;;
&#125;;</code></pre>
<h4 id="flat-的实现">flat 的实现<a class="post-anchor" href="#flat-的实现"></a></h4><p>ES6 中新增了 flat 方法，将多位数组变为低维数组。如果不传参数默认为一层，传参数可以规定展平的层级。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">arr</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.isArray(arr);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFlat</span>(<span class="hljs-params">arr</span>) </span>&#123;
  <span class="hljs-keyword">var</span> result = [];
  <span class="hljs-keyword">var</span> deep = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">1</span> : <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]; <span class="hljs-comment">//判断是否传入展平层级</span>
  arr.forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (isArray(element) &amp;&amp; deep &gt;= <span class="hljs-number">1</span>) &#123;
      result = result.concat(myFlat(element, deep - <span class="hljs-number">1</span>));
    &#125; <span class="hljs-keyword">else</span> &#123;
      result.push(element);
    &#125;
  &#125;);
  <span class="hljs-keyword">return</span> result;
&#125;</code></pre>
<h3 id="防抖-节流">防抖 / 节流<a class="post-anchor" href="#防抖-节流"></a></h3><p>在 resize/scroll/keypress/mousemove 等事件触发时，会不断调用回调函数。</p>
<p>在我们实现搜索的时候，输入搜索内容进行模糊搜索的时候，也会不断调用回调函数，这样子性能就被降低了。</p>
<p>对于这类事件的处理方式就是使用事件节流和事件防抖。它们通过对事件对应的回调函数进行包裹，以自由变量的形式缓存时间信息。</p>
<ul>
<li><p>防抖(debounce)<br>假设设置时间为 2000ms，如果触发事件的 2000ms 之内，你再次触发该事件，就会给新的事件添加新的计时器，之前的事件统统作废。只执行最后一次触发的事件。</p>
<p>在某段时间内，不管你触发了多少次事件，我都只认最后一次。</p>
</li>
</ul>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;
  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> _this = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;
    clearTimeout(timer);
    timer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      fn.apply(_this, args);
    &#125;, delay);
  &#125;;
&#125;</code></pre>
<ul>
<li>节流()<br>在某段时间内，不管你触发了多少次事件，我都只认第一次，并在计时结束时给予响应。<br>假设设置的时间为 2000ms，再触发了事件的 2000ms 之内，你在多少触发该事件，都不会有任何作用，它只为第一个事件等待 2000ms。时间一到，它就会执行了。</li>
</ul>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;
  <span class="hljs-keyword">let</span> pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> _this = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;
    <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
    <span class="hljs-keyword">if</span> (now - pre &gt; delay) &#123;
      fn.apply(_this, args);
      pre = now;
    &#125;
  &#125;;
&#125;</code></pre>
<h3 id="jsonp-的实现">jsonp 的实现<a class="post-anchor" href="#jsonp-的实现"></a></h3><p>jsonp 的作用是解决跨域问题。<br>因为 script 标签不受同源策略限制，所以可以动态插入 script 实现跨域。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">url, data</span>) </span>&#123;
  data = data || &#123;&#125;;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle, reject</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">const</span> cbFn = <span class="hljs-string">`jsonp_<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>;
    data.callback = cbFn;
    <span class="hljs-keyword">const</span> head = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"head"</span>);
    <span class="hljs-keyword">const</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);
    <span class="hljs-keyword">const</span> src = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;dataToUrl(data)&#125;</span>`</span>;
    script.src = src;
    head.append(script);
    <span class="hljs-built_in">window</span>[ncbFn] = <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;
      resovle(res);
      head.removeChild(script);
      <span class="hljs-built_in">window</span>[cbFn] = <span class="hljs-literal">null</span>;
    &#125;;
  &#125;);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataToUrl</span>(<span class="hljs-params">data</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(data)
    .reduce(<span class="hljs-function">(<span class="hljs-params">pre, curr</span>) =&gt;</span> &#123;
      pre.push(<span class="hljs-string">`<span class="hljs-subst">$&#123;curr&#125;</span>=<span class="hljs-subst">$&#123;data[curr]&#125;</span>`</span>);
      <span class="hljs-keyword">return</span> pre;
    &#125;, [])
    .join(<span class="hljs-string">"&amp;"</span>);
&#125;

jsonp(<span class="hljs-string">"http://jsonplaceholder.typicode.com/comments"</span>, &#123;
  <span class="hljs-attr">postId</span>: <span class="hljs-number">1</span>
&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.log(res);
&#125;);</code></pre>
<h4 id="函数柯里化">函数柯里化<a class="post-anchor" href="#函数柯里化"></a></h4><p>当某个函数一次需要接受多个参数时，可以使用柯里化来使得当前函数一次性接受少一点的参数。</p>
<p>百科：把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">carry</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">const</span> args = [...arguments].slice(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">if</span> (fn.length &lt;= args.length) &#123;
    <span class="hljs-comment">//当传入参数的数量&gt;=函数参数数量时，执行函数</span>
    <span class="hljs-keyword">return</span> fn(...args);
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">//返回一个函数，等待传入其他参数</span>
    <span class="hljs-keyword">const</span> args1 = [...arguments];
    <span class="hljs-keyword">return</span> carry(fn, ...args, ...args1);
  &#125;;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;
  <span class="hljs-keyword">return</span> a + b + c;
&#125;

<span class="hljs-keyword">const</span> carryAdd = carry(add);

carryAdd(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
carryAdd(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
carryAdd(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>);
carryAdd(<span class="hljs-number">1</span>)()(<span class="hljs-number">2</span>)()(<span class="hljs-number">3</span>);</code></pre>
<h4 id="LazyMan-链式调用">LazyMan(链式调用)<a class="post-anchor" href="#LazyMan-链式调用"></a></h4><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LazyMan</span>(<span class="hljs-params">name</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> _LazyMan(name);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_LazyMan</span>(<span class="hljs-params">name</span>) </span>&#123;
  <span class="hljs-keyword">this</span>.name = name;
  <span class="hljs-keyword">this</span>.queue = []; <span class="hljs-comment">//初始化队列</span>
  <span class="hljs-keyword">this</span>.queue.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hi, "</span> + name);
    <span class="hljs-keyword">this</span>.next();
  &#125;);
  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
    <span class="hljs-keyword">this</span>.next();
  &#125;, <span class="hljs-number">0</span>);
&#125;

_LazyMan.prototype.next = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">this</span>.queue.shift();
  fn &amp;&amp; fn();
&#125;;

_LazyMan.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">food</span>) </span>&#123;
  <span class="hljs-keyword">this</span>.queue.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">" eat "</span> + food);
    <span class="hljs-keyword">this</span>.next();
  &#125;);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;;

_LazyMan.prototype.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">time</span>) </span>&#123;
  <span class="hljs-keyword">this</span>.queue.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">" sleep "</span> + time + <span class="hljs-string">"s"</span>);
      <span class="hljs-keyword">this</span>.next();
    &#125;, time * <span class="hljs-number">1000</span>);
  &#125;);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;;</code></pre>
<h4 id="数组去重">数组去重<a class="post-anchor" href="#数组去重"></a></h4><ul>
<li>双重循环(兼容性好)</li>
</ul>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">nums</span>) </span>&#123;
  <span class="hljs-keyword">var</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; result.length; j++) &#123;
      <span class="hljs-keyword">if</span> (nums[i] === result[j]) &#123;
        <span class="hljs-keyword">break</span>;
      &#125;
    &#125;
    <span class="hljs-keyword">if</span> (j === result.length) &#123;
      result.push(nums[i]);
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> result;
&#125;</code></pre>
<ul>
<li>indexOf(简化上一个方法的内部操作)</li>
</ul>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">nums</span>) </span>&#123;
  <span class="hljs-keyword">var</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
    <span class="hljs-keyword">if</span> (result.indexOf(nums[i]) === <span class="hljs-number">-1</span>) &#123;
      result.push(nums[i]);
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> result;
&#125;</code></pre>
<ul>
<li>includes 实现(思路和上述方法一直，api 调用不同)</li>
</ul>
<pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.unique = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">const</span> result = [];
  arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (!result.includes(item)) &#123;
      result.push(item);
    &#125;
  &#125;);
  <span class="hljs-keyword">return</span> result;
&#125;;</code></pre>
<ul>
<li>reduce + sort 实现(先排序在去重)</li>
</ul>
<pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.unique = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">return</span> arr
    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)
    .reduce(<span class="hljs-function">(<span class="hljs-params">pre, curr</span>) =&gt;</span> &#123;
      <span class="hljs-keyword">if</span> (pre.length === <span class="hljs-number">0</span> || pre[pre.length - <span class="hljs-number">1</span>] !== curr) &#123;
        pre.push(curr);
      &#125;
      <span class="hljs-keyword">return</span> pre;
    &#125;, []);
&#125;;</code></pre>
<ul>
<li>对象实现<br>可以使用普通对象，或者使用 ES6 Map</li>
</ul>
<pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.unique = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">//只能存在一个key</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> !map.has(item) &amp;&amp; map.set(item, <span class="hljs-number">1</span>);
  &#125;);
&#125;;

<span class="hljs-built_in">Array</span>.prototype.unique = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> obj = &#123;&#125;;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> obj.hasOwnProperty(item) ? <span class="hljs-literal">false</span> : (obj[item] = <span class="hljs-literal">true</span>);
  &#125;);
&#125;;</code></pre>
<ul>
<li>Set 数据结构</li>
</ul>
<pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.unique = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...this]));
&#125;;</code></pre>


  
    <div class="post-reward">
    <div id="reward-button">打赏</div>
      <div id="qr">
        <div class="wrap">
            
            <div class="bg-wrap">
              <a href="/images/zhifubao.jpg" target="_block" class="bg" style="background-image:url('/images/zhifubao.jpg')"></a>
              支付宝
            </div>
            
            
            <div class="bg-wrap">
                <a href="/images/weixin.jpg" target="_block" class="bg" style="background-image:url('/images/weixin.jpg')"></a>
              微信
            </div>
            
        </div>
      </div>
    </div>
  
  <div class="post-guide">
    <div class="item left">
        
          <a href="/2019/03/05/今日份感想/">今日份感想</a>
        
    </div>
    <div class="item right">
        
          <a href="/2019/02/13/垂直居中/">如何实现元素居中</a>
        
    </div>
  </div>

  

  <div class="post-copyright">
    <div class="auth">
      本文作者：<a href="https://luckyfbb.github.io">FBB</a>
    </div>
    <div class="link">
      永久链接：<a href="https://luckyfbb.github.io/2019/02/14/JS原生实现/">https://luckyfbb.github.io/2019/02/14/JS原生实现/</a>
    </div>
    <div class="declare">
      版权声明：本文首发于<a href="https://luckyfbb.github.io">FBB</a>的博客，转载请注明出处！
    </div>
  </div>

  <div id="comment"></div>

  
  
</article>
        <footer>
          <div class="copyright">
            ©2019
            <a href="https://luckyfbb.github.io">FBB</a> Powered by <a href="https://hexo.io">Hexo</a> |
            <a href="https://github.com/shixiaohu2206/hexo-theme-huhu">hexo-theme-huhu</a>
          </div>
          
        </footer>
      </div>
    </div>
  </body>
  
</html>
<script type="text/javascript">
                  window.HUHU_CONFIG = JSON.parse("{\"share\":[\"weibo\",\"weixin\",\"qqkongjian\",\"QQ\",\"douban\",\"facebook\",\"twitter\",\"google\"],\"service_worker\":{\"open\":false}}")
                </script> <script type="text/javascript">window.addEventListener('load', function() {
    
    window.loadJs = function(d, m, a) {
      var c = document.getElementsByTagName('head')[0] || document.head || document.documentElement
      var b = document.createElement('script')
      b.defer = true
      b.setAttribute('type', 'text/javascript')
      b.setAttribute('charset', 'UTF-8')
      b.setAttribute('async', 'true')
      b.setAttribute('src', d)
      m && b.setAttribute('data-main', '/scripts/app-built')
      if (typeof a === 'function') {
        if (window.attachEvent) {
          b.onreadystatechange = function() {
            var e = b.readyState
            if (e === 'loaded' || e === 'complete') {
              b.onreadystatechange = null
              a()
            }
          }
        } else {
          b.onload = a
        }
      }
      c.appendChild(b)
    }
    window.loadJs && window.loadJs('https://cdn.bootcss.com/require.js/2.3.6/require.min.js', true, function() {require.config({"paths":{"util":"util","share":"share","search":"search","registerSW":"registerSW","valine":"cdn/Valine.min","av":["https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min"],"pjax":["https://cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min"],"jquery":["https://cdn.bootcss.com/jquery/3.4.1/jquery.min"],"confirm":["https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min"],"fancybox":["https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min"],"chart":["https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.bundle.min"]},"map":{"*":{"css":"https://cdn.bootcss.com/require-css/0.1.10/css.min.js"}},"shim":{"fancybox":{"deps":["css!https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css"]},"confirm":{"deps":["css!https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min.css"]},"chart":{"deps":["css!https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.min.css"]}},"waitSeconds":3})})
  })</script> <script type="text/javascript">
                  ;(function() {
                    var bp = document.createElement('script')
                    var curProtocol = window.location.protocol.split(':')[0]
                    if (curProtocol === 'https') {
                      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'
                    } else {
                      bp.src = 'http://push.zhanzhang.baidu.com/push.js'
                    }
                    var s = document.getElementsByTagName('script')[0]
                    s.parentNode.insertBefore(bp, s)
                  })()
                </script> 
