<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            JavaScript高级教程
        
    </title>
    <link rel="icon" href="/blog.github.io/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            FBB
        </a>
    </h1>
    <h2>
        <a class="motto">
            think more, learn more !
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://luckyfbb.github.io/resume/" class="menu-item-link">
                        Resume
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/LuckyFBB/" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                
                
        </ul>
    </nav>
</header>
    <main class="main">
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/26/JS高级教程/"> 
                    JavaScript高级教程 
                </a>
            </h1>
            <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-26   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li></ul>
            </div>
<div class="toc">
  <ol class="toc-list"><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#在HTML中使用JavaScript"><span class="toc-list-text">在HTML中使用JavaScript</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#script元素"><span class="toc-list-text">script元素</span></a></li></ol></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#基本概念"><span class="toc-list-text">基本概念</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#语法"><span class="toc-list-text">语法</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#变量"><span class="toc-list-text">变量</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#数据类型"><span class="toc-list-text">数据类型</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#操作符"><span class="toc-list-text">操作符</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-6"><a class="toc-list-link" href="#布尔操作符"><span class="toc-list-text">布尔操作符</span></a></li><li class="toc-list-item toc-list-level-6"><a class="toc-list-link" href="#相等操作符"><span class="toc-list-text">相等操作符</span></a></li><li class="toc-list-item toc-list-level-6"><a class="toc-list-link" href="#条件操作符"><span class="toc-list-text">条件操作符</span></a></li></ol></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#函数"><span class="toc-list-text">函数</span></a></li></ol></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#变量、作用域和内存问题"><span class="toc-list-text">变量、作用域和内存问题</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#基本类型和引用类型的值"><span class="toc-list-text">基本类型和引用类型的值</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#执行环境及作用域"><span class="toc-list-text">执行环境及作用域</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#垃圾收集"><span class="toc-list-text">垃圾收集</span></a></li></ol></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#引用类型"><span class="toc-list-text">引用类型</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#Object类型"><span class="toc-list-text">Object类型</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#Array类型"><span class="toc-list-text">Array类型</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#Function类型"><span class="toc-list-text">Function类型</span></a></li></ol></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#面向对象的程序设计"><span class="toc-list-text">面向对象的程序设计</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#对象的理解"><span class="toc-list-text">对象的理解</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#原型对象"><span class="toc-list-text">原型对象</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#继承"><span class="toc-list-text">继承</span></a></li></ol></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#函数表达式"><span class="toc-list-text">函数表达式</span></a></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#BOM对象"><span class="toc-list-text">BOM对象</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#window对象"><span class="toc-list-text">window对象</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#location对象"><span class="toc-list-text">location对象</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#history对象"><span class="toc-list-text">history对象</span></a></li></ol></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#DOM"><span class="toc-list-text">DOM</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#节点层次"><span class="toc-list-text">节点层次</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#选择符API"><span class="toc-list-text">选择符API</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#元素遍历"><span class="toc-list-text">元素遍历</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#HTML5"><span class="toc-list-text">HTML5</span></a></li></ol></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#DOM2和DOM3"><span class="toc-list-text">DOM2和DOM3</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#样式"><span class="toc-list-text">样式</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#遍历"><span class="toc-list-text">遍历</span></a></li></ol></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#事件"><span class="toc-list-text">事件</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#事件流"><span class="toc-list-text">事件流</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#事件处理程序"><span class="toc-list-text">事件处理程序</span></a></li><li class="toc-list-item toc-list-level-5"><a class="toc-list-link" href="#事件对象"><span class="toc-list-text">事件对象</span></a></li></ol></li></ol>
</div>
            <div class="content">
                <p>准备春招的过程中，重读JS高级教程。记录一下一些知识点。<a id="more"></a></p>
<h4 id="在HTML中使用JavaScript"><a href="#在HTML中使用JavaScript" class="headerlink" title="在HTML中使用JavaScript"></a>在HTML中使用JavaScript</h4><h5 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h5><ol>
<li><p>六个属性<br>async: 表示立即下载脚本。但是不影响页面的其他操作。只对外部脚本有效。<br>charset: 表示通过src属性指定的代码字符集。不常用。<br>defer: 表示脚本延迟到文档完全被解析和显示之后在执行。只对外部脚本有效。<br>language: 已废弃。<br>src: 表示要执行的外部脚本。<br>type: 表示编写代码使用的脚本语言的内容类型。</p>
</li>
<li><p>标签的位置</p>
<ul>
<li>页面的head元素内<br>意味着必须等到所有的JavaScript代码都被下载、解析和执行完成之后，才能开始呈现页面的内容。<strong>这会导致浏览器在呈现页面的时候出现延迟，在此期间浏览器一片空白。</strong></li>
<li>body内容后面<br>在解析JavaScript代码之前，页面内容可以被完全呈现。也会缩短浏览器空白页的事件。</li>
</ul>
</li>
<li><p>延迟脚本(defer)<br>表明脚本在执行时不会影响页面的构造。脚本会延迟执行，等待页面都解析完毕之后在运行。等同于告诉浏览器<strong>立即下载，延迟执行。</strong>最后执行的顺序按照先后顺序执行。</p>
</li>
<li><p>异步脚本(async)<br>不让页面等待脚本下载和执行，从而异步加载页面其他内容。<strong>下载完立即执行</strong>。不能保证加载顺序，谁先下载好谁执行。</p>
</li>
</ol>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ol>
<li>标识符(大多采用驼峰大小写格式)<ul>
<li>第一个字符必须是一个字母，下划线(_)或者一个美元符号($)</li>
<li>其他字符可以是字母、下划线、美元符号、数字</li>
</ul>
</li>
</ol>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>ECMAScript的变量是松散类型的，就是可以用来保存任何类型的数据。</p>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>五种基本类型: Undefined/Null/Boolean/String/Number/Symbol(ES6新增)</p>
<p>一个复杂类型: Object</p>
<ol>
<li><p>typeof操作符<br>undefined/boolean/string/number/object/function</p>
</li>
<li><p>Undefined类型<br>Undefined类型只有一个值，即特殊的undefined。<br>使用var声明变量但是没有初始化时，这个值就是undefined。<br>对于没有声明的变量，执行typeof依旧返回undefined。</p>
<pre><code>var message;
typeof message;     //undefined
typeof age;         //undefined
</code></pre></li>
<li><p>Null类型<br>Null类型是第二个只有一个值的数据类型，这个特殊值是null。</p>
<pre><code>type null   //object
</code></pre></li>
<li><p>Boolean类型<br>Boolean类型只用两个字面值: true/false<br>Boolean()转换规则<br><img src="https://upload-images.jianshu.io/upload_images/12814322-6bea20d14d72eb51.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.jpg"></p>
</li>
<li><p>Number类型<br>NaN，非数值是一个特殊的数值。<br>Number()转换规则</p>
<ul>
<li>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。  如果是数字值，只是简单的传入和返回。</li>
<li>如果是 null 值，返回 0。</li>
<li>如果是 undefined，返回 NaN。</li>
<li>如果是字符串，遵循下列规则:</li>
<li><ul>
<li>如果字符串中只包含数字(包括前面带正号或负号的情况)，则将其转换为十进制数值，即”1” 会变成 1，”123”会变成 123，而”011”会变成 11(注意:前导的零被忽略了);</li>
</ul>
</li>
<li><ul>
<li>如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值(同样，也会忽 略前导零);</li>
</ul>
</li>
<li><ul>
<li>如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整 数值;</li>
</ul>
</li>
<li><ul>
<li>如果字符串是空的(不包含任何字符)，则将其转换为 0;</li>
</ul>
</li>
<li><ul>
<li>如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</li>
</ul>
</li>
<li>如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。</li>
</ul>
<pre><code>❗️❗️❗️  0.1+0.2==0.3   //false,浮点数精度问题
</code></pre></li>
<li><p>String类型</p>
<ul>
<li>如果值有 toString()方法，则调用该方法(没有参数)并返回相应的结果; </li>
<li>如果值是 null，则返回”null”;</li>
<li>如果值是 undefined，则返回”undefined”。</li>
</ul>
</li>
<li><p>Object类型<br>对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。</p>
<ul>
<li>constructor:保存着用于创建当前对象的函数。对于前面的例子而言，构造函数(constructor) 8 就是 Object()。</li>
<li>hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例 的原型中)是否存在。其中，作为参数的属性(propertyName)必须以字符串形式指定(例 如:o.hasOwnProperty(“name”))。</li>
<li>isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型(第 5 章将讨论原 型)。</li>
<li>propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句 (本章后面将会讨论)来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。</li>
<li>toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString():返回对象的字符串表示。 </li>
<li>valueOf():返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。</li>
</ul>
</li>
</ol>
<h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><h6 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h6><ol>
<li><p>逻辑非<br>逻辑非操作符由一个叹号(!)表示，逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再 对其求反。</p>
<ul>
<li>如果操作数是一个对象，返回 false;</li>
<li>如果操作数是一个空字符串，返回 true;</li>
<li>如果操作数是一个非空字符串，返回 false;</li>
<li>如果操作数是数值 0，返回 true;</li>
<li>如果操作数是任意非 0 数值(包括 Infinity)，返回 false;  如果操作数是 null，返回 true;</li>
<li>如果操作数是 NaN，返回 true;</li>
<li>如果操作数是 undefined，返回 true。</li>
</ul>
</li>
<li><p>逻辑与<br>逻辑与操作符由两个和号(&amp;&amp;)表示，有两个操作数。</p>
<ul>
<li>如果第一个操作数是对象，则返回第二个操作数;</li>
<li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象;</li>
<li>如果两个操作数都是对象，则返回第二个操作数;</li>
<li>如果有一个操作数是 null，则返回 null;</li>
<li>如果有一个操作数是 NaN，则返回 NaN;</li>
<li>如果有一个操作数是 undefined，则返回 undefined。</li>
</ul>
</li>
<li><p>逻辑或<br>逻辑或操作符由两个竖线符号(||)表示，有两个操作数。</p>
<ul>
<li>如果第一个操作数是对象，则返回第一个操作数;</li>
<li>如果第一个操作数的求值结果为 false，则返回第二个操作数;  如果两个操作数都是对象，则返回第一个操作数;</li>
<li>如果两个操作数都是 null，则返回 null;</li>
<li>如果两个操作数都是 NaN，则返回 NaN;</li>
<li>如果两个操作数都是 undefined，则返回 undefined。</li>
</ul>
</li>
</ol>
<h6 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h6><ol>
<li><p>相等和不相等<br>相等操作符由两个等于号(==)表示，如果两个操作数相等，则返回 true。而不 相等操作符由叹号后跟等于号(!=)表示，如果两个操作数不相等，则返回 true。这两个操作符都会，先转换操作数(通常称为强制转型)，然后再比较它们的相等性。</p>
</li>
<li><p>全等和不全等<br>不会进行类型转换，其他与相等和不相等类似。</p>
</li>
</ol>
<h6 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h6><pre><code>variable = boolean_expression ? true_value : false_value;
</code></pre><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ol>
<li><p>参数<br>在函数体内可以通过arguments对象来访问这个参数数组，从而获得传递给函数的每一个参数。它是一个类数组。</p>
</li>
<li><p>没有重载<br>在Java中，函数名一样，接受的参数类型和数量不同，就构成了函数重载。但是在ECMAScript中参数是由包含0个或多个值的数组表示的。所以不能构成重载。<br>如果定义了两个相同的函数，改名字属于后定义的函数。<br>可以根据arguments传入的数量来模仿重载。</p>
</li>
</ol>
<h4 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h4><h5 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h5><p>基本类型是指简单的数据段。引用类型是指可能由多个值构成的对象。</p>
<p>基本类型保存在栈内存中，引用类型保存在堆内存中。</p>
<p>引用类型值的变量实际上包含的并不是对象本身，而是指向该对象的指针。</p>
<p>引用对象复制的时候，其实是复制的指针，最终两者都指向同一个对象。</p>
<ol>
<li><p>传递参数<br>ECMAScript中所有函数的参数都是按值传递的。</p>
</li>
<li><p>检测类型<br>检测基本类型，使用typeof操作符是最佳的工具。<br>使用instanceof操作符检测是什么类型的对象。</p>
</li>
</ol>
<pre><code>result = variable instanceof constructor
</code></pre><h5 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h5><ol>
<li><p>作用域链<br>保证对执行环境有权访问的所有变量和函数的有序访问。</p>
</li>
<li><p>延长作用域链<br>try-catch语句中的catch块<br>with语句</p>
</li>
<li><p>没有块级作用域</p>
</li>
</ol>
<pre><code>if (true) {
  var color = &#39;blue&#39;
}
console.log(color)    //blue
</code></pre><p>在函数内部，最接近的环境就是函数的局部环境。</p>
<pre><code>function add(num1,num2) {
  var sum = num1 + num2
  return sum
}
alert(sum)   //不是有效的变量。
</code></pre><p>如果省略var等同于把sum挂载到全局作用域</p>
<pre><code>function add(num1,num2) {
  sum = num1 + num2
  return sum
}
alert(sum)   //30
</code></pre><h5 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h5><ol>
<li><p>标记清除<br>当变量进入环境的时候，就将这个变量标记为’进入环境’，当变量离开环境的时候，则将其标记成为’离开环境’。</p>
</li>
<li><p>引用计数<br>跟踪记录每一个值被引用的次数。当引用次数为0的时候，就没有办法在访问这个值了，将其内存空间收回。</p>
</li>
</ol>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><h5 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h5><ol>
<li>创建方式</li>
</ol>
<pre><code>var person = new Object();
person.name = &#39;FBB&#39;;
person.age = 18;

var person = {
  name = &#39;FBB&#39;,
  age = 18
}
</code></pre><h5 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h5><ol>
<li><p>创建方式</p>
<pre><code>var arr = new Array();    //创建一个数组
var arr = new Array(20);    //创建一个长度为20的数组
var arr = new Array(&#39;FBB&#39;, &#39;Lucky&#39;);    //创建包含两个字段的数组
var arr = [&#39;FBB&#39;, &#39;Lucky&#39;]
</code></pre></li>
<li><p>数组检测<br>使用instanceof，ES5的Array.isArray，Object.prototype.toString.call(obj)===”[object Array]”检测</p>
</li>
<li><p>栈方法</p>
<ul>
<li>push()接受任意数量的参数，在数组末尾添加参数，返回数组长度</li>
<li>pop()移除最后一项，返回移除的值</li>
</ul>
</li>
<li><p>队列方法</p>
<ul>
<li>push()接受任意数量的参数，返回数组长度</li>
<li>shift()移除数组第一项并且返回该项</li>
<li>unshift()接受任意数量的参数，在数组头部添加参数，返回数组长度</li>
</ul>
</li>
<li><p>重排序方法</p>
<ul>
<li>sort()排序</li>
<li>reverse()反转</li>
</ul>
</li>
<li><p>操作方法</p>
<ul>
<li>slice()基于当前数组中的一或者多项创建一个新数组，不改变原数组。接受两个参数，slice(start, end)，前闭后开 [start, end)</li>
<li>splice()</li>
</ul>
</li>
<li><p>位置方法</p>
<ul>
<li>indexOf()从数组开始往后查找</li>
<li>lastIndexOf()从数组末尾往前查找</li>
</ul>
</li>
<li><p>迭代方法</p>
<ul>
<li>every()对数组的每一项执行函数，如果函数每一项都返回true，则返回true</li>
<li>filter()对数组的每一项执行函数，返回该函数会返回true的项组成数组</li>
<li>forEach()对数组的每一项执行函数，没有返回值</li>
<li>map()对数组的每一项执行函数，返回每次函数调用的结果组成数组</li>
<li>some()对数组的每一项执行函数，如果任意一项返回true，则返回true</li>
</ul>
</li>
</ol>
<h5 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h5><ol>
<li>函数定义<br>函数声明</li>
</ol>
<pre><code>function sum (num1, num2) {    //能够函数提升，将所有的函数声明都放到顶部
  return num1 + num2
}
</code></pre><p>函数表达式</p>
<pre><code>var sum = function(num1, num2) {    //不能函数提升
  return num1 + num2
}
</code></pre><ol start="2">
<li><p>函数内部属性<br>在函数内部，有两个特殊的对象: arguments和this</p>
</li>
<li><p>函数属性和方法<br>每个函数都包含两个属性: length和prototype<br>length表示函数接受的命名参数的个数<br>prototype是保存它们所有实例的真正所在</p>
</li>
</ol>
<h4 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h4><h5 id="对象的理解"><a href="#对象的理解" class="headerlink" title="对象的理解"></a>对象的理解</h5><ol>
<li><p>数据属性<br>只能通过Object.defineProperty()方法修改默认属性特性。</p>
<ul>
<li>Configurable: 表示能否通过delete删除属性，默认值true</li>
<li>Enumerable: 表示是否通过for-in循环属性，默认值true</li>
<li>Writable: 表示是否可以修改属性，默认值true</li>
<li>Value: 表示这个属性的属性值，默认值undefined</li>
</ul>
<pre><code>var person = {}
Object.defineProperty(person, &#39;name&#39;, {
 configurable: false,
 value: &#39;FBB&#39;
})
console.log(person.name)    //FBB
delete(person.name)
console.log(person.name)    //FBB
</code></pre></li>
<li><p>访问器属性</p>
<ul>
<li>Configurable: 表示能否通过delete删除属性，默认值true</li>
<li>Enumerable: 表示是否通过for-in循环属性，默认值true</li>
<li>Get: 在读取属性时调用的函数，默认值为undefined</li>
<li>Set: 在写入属性时调用的函数，默认值为undefined<pre><code>var person = {
_age: 0,
name: &#39;FBB&#39;,
desr: &#39;&#39;
}
Object.defineProperty(person, &#39;age&#39;, {
get: function(){
 return this._age
},
set: function(value){
 this._age = value
 if (value &lt; 18) {
   this.desr = &#39;未成年&#39;
 } else {
   this.desr = &#39;成年人&#39;
 }
}
})
</code></pre></li>
</ul>
</li>
</ol>
<h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5><ol>
<li>理解原型<pre><code>Person.prototype.constructor = Person
new Person().__proto__ = Person.prototype
</code></pre>使用obj.hasOwnProperty()判断属性来自实例还是原型，实例里面返回true，远行里面<br>in操作符也能够访问给定属性时返回true，不管该属性是实例中的还是原型中的</li>
</ol>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p><a href="https://luckyfbb.github.io/blog.github.io/2019/01/15/class/">继承</a></p>
<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><ol>
<li><p>递归<br>arguments.callee指向正在执行的函数指针，可以用来实现递归</p>
</li>
<li><p>闭包<br>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
</li>
<li><p>this对象<br><a href="https://segmentfault.com/a/1190000011194676?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com&amp;share_user=1030000000178452" target="_blank" rel="noopener">this绑定</a></p>
</li>
<li><p>模仿块级作用域<br>用作块级作用域(通常称为私有作用域)的匿名函数</p>
</li>
</ol>
<pre><code>(function(){

})()   //立即调用了一个匿名函数
</code></pre><ol start="5">
<li>私有变量<br>在函数内部创建一个闭包，通过闭包的作用域链也可以访问到变量。</li>
</ol>
<h4 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h4><h5 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h5><p>DOM的核心对象是window，表示浏览器的一个实例。</p>
<ol>
<li>窗口位置<br>提供了screenLeft和screenTop属性，分别用于表示窗口相对于屏幕左边和上边的属性。</li>
<li>窗口大小<br>innerWidth/innerHeight是表示该容器中页面视图区的大小<br>outerWidth/outerHeight返回浏览器窗口本身的尺寸</li>
<li>导航和打开窗口<br>window.open()既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口</li>
<li>间歇调用和超时调用<br>前者是在指定的时间过后执行代码，后者是每隔指定的时间就执行一次代码<br>第一个参数要执行的代码，第二个参数以毫秒表示的时间<br>使用clearTimerout()/clearInterval()清除调用</li>
</ol>
<h5 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h5><p>location对象是一个很特别的对象，因为它既是window对象，document对象的属性</p>
<p>每次修改location的属性(hash除外)，页面都会重新加载URL</p>
<p>修改hash/search/hostname/pathname/port之后，浏览器的历史记录就会生成一条新的记录</p>
<h5 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h5><p>history对象保存着用户上网的历史记录，从窗口被打开的那一刻开始算起</p>
<p>history.go()在用户的历史记录中任意跳转，可以向前向后</p>
<p>history.back()/history.forward()分别表示’后退’和’前进’</p>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><h5 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h5><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。</p>
<p>文档节点只有一个子节点，即<html>元素，称之为文档元素。<br><!-- 1. Node类型
appenChild(node): 插入的节点，将成为传入父节点的最后一个节点
insertBefore(node, referenceNode): 插入的节点，将成为参照节点的前一个同胞节点
replaceChile(node, replaceNode): 替换节点，替换的节点将从文档树中移除，同时插入的节点占据其位置
removeChild(node): 移除某一个节点，移除的节点成为返回值 --></html></p>
<h5 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h5><ul>
<li>querySelector(): 返回与该模式匹配的第一个元素，若没有返回null</li>
<li>querySelectorAll(): 返回与该模式匹配的所有元素，返回的是一个NodeList实例</li>
<li>matchesSelector()</li>
</ul>
<h5 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h5><p>childElementCount: 返回子元素(不包括文本节点和注释)的个数</p>
<p>firstElementChild: 指向第一个子元素;firstChild 的元素版</p>
<p>lastElementChild: 指向最后一个子元素;lastChild 的元素版</p>
<p>previousElementSibling: 指向前一个同辈元素;previousSibling 的元素版</p>
<p>nextElementSibling: 指向后一个同辈元素;nextSibling 的元素版</p>
<h5 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h5><ol>
<li><p>getElementsByClassName()方法</p>
</li>
<li><p>classList属性<br>add(value): 添加字符串<br>remove(value): 删除字符串<br>contains(value): 返回列表中是否包含字符串<br>toggle(value): 字符串中没有这个值就删除，有就添加</p>
</li>
<li><p>自定义属性</p>
<pre><code>&lt;div id=&#39;myDiv&#39; data-appId=&#39;123&#39; data-myname=&#39;FBB&#39; /&gt;
可以使用div.dataset.appId/myname 访问到
</code></pre></li>
<li><p>插入标记</p>
<ul>
<li>innnerHTML返回与调用子元素的所有子节点的HTML标签</li>
<li>outerHTML返回调用它的元素及所有子节点的HTML标签</li>
</ul>
</li>
<li><p>scrollIntoView()<br>通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中</p>
</li>
</ol>
<h4 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h4><h5 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h5><ol>
<li><p>偏移量</p>
<ul>
<li>offsetHeight: 元素在垂直方向上占用的空间大小</li>
<li>offsetWidth: 元素在水平方向上占用的空间大小</li>
<li>offsetLeft: 元素的左外边框至包含元素的左内边框之间的像素距离</li>
<li>offsetRight: 元素的上外边框至包含元素的上内边框之间的像素距离<br><img src="https://upload-images.jianshu.io/upload_images/12814322-5bf719362bc3791e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></li>
</ul>
</li>
<li><p>客户区大小</p>
<ul>
<li>clientHeight: 元素内容高度加上上下内边距高度</li>
<li>clientWidth: 元素内容款度加上左右内边距宽度<br><img src="https://upload-images.jianshu.io/upload_images/12814322-126b73dc91048743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></li>
</ul>
</li>
<li><p>滚动大小</p>
<ul>
<li>scrollHeight: 在没有滚动条的情况下，元素内容的总高度</li>
<li>scrollWidth: 在没有滚动条的情况下，元素内容的总宽度</li>
<li>scrollLeft: 被隐藏在内容区域左侧的像素数</li>
<li>scrollTop: 被隐藏在内容区域上侧的像素数<br><img src="https://upload-images.jianshu.io/upload_images/12814322-3b61c1c48f2ea013.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></li>
</ul>
</li>
</ol>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><ol>
<li><p>NodeIterator<br>使用document.createInterator(root, whatToShow, filter, entityReferenceExpansion)方法创建出实例<br>NodeIterator类两个方法，nextNode()和previousNode()</p>
</li>
<li><p>TreeWorker<br>使用document.createTreeWorker(root, whatToShow, filter, entityReferenceExpansion)方法创建出实例<br>TreeWorker类五个方法</p>
<ul>
<li>parentNode(): 当前节点的父节点</li>
<li>firstChild(): 当前节点的第一个子节点</li>
<li>lastChild(): 当前节点的最后一个子节点</li>
<li>nextSibling(): 当前节点的下一个同辈节点</li>
<li>previousSibling(): 当前节点的前一个同辈节点</li>
</ul>
</li>
</ol>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><h5 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h5><p>事件流描述的是从页面中接受事件的顺序</p>
<ol>
<li><p>事件冒泡<br>IE的事件流叫做事件冒泡，即事件开始是从最具体的元素接收，然后逐级向上到较为不具体的节点，直至传播到document对象(某些传播至window对象)</p>
</li>
<li><p>事件捕获<br>事件捕获是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件(某些从window对象开始捕获)</p>
</li>
<li><p>DOM事件流<br>DOM2级事件的三个阶段: 事件捕获阶段、处于目标阶段、事件冒泡阶段<br><img src="https://upload-images.jianshu.io/upload_images/12814322-0a90f8bf42ad9dae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br>事件处理被看成冒泡阶段的一部分</p>
</li>
</ol>
<h5 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h5><p>响应某一个事件的函数就叫做事件处理程序</p>
<ol>
<li><p>HTML事件处理程序</p>
<pre><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&#39;Clicked&#39;)&quot; /&gt;
</code></pre></li>
<li><p>DOM0级事件处理程序</p>
<pre><code>btn.onclick = function() {   //设置事件处理程序，在事件流冒泡阶段被处理
//action
}
btn.onclick = null   //删除事件处理程序 
</code></pre></li>
<li><p>DOM2级事件处理程序<br>两个方法: addEventListener()/removeEventListener()</p>
<pre><code>btn.addEventListener(&#39;click&#39;, function(){
//action
}, false)   //false表示在冒泡阶段调用事件处理程序，true表示在捕获阶段调用事件处理程序
多个则按着顺序执行
</code></pre></li>
<li><p>IE事件处理程序<br>attachEvent()/detachEvent(): 两个参数事件处理程序名称与事件处理程序函数</p>
</li>
</ol>
<h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h5><ol>
<li><p>DOM中的事件对象<br>无论指定事件处理程序时使用说明方法，都会传入event对象。<br>currentTarget当前事件处理程序正在处理的那个元素<br>target事件目标<br>使用preventDefault()阻止特定事件的默认行为<br>使用stopPropagation()停止事件在DOM层次中的传播，即取消冒泡或捕获</p>
</li>
<li><p>IE中的事件对象<br>event对象是作为window对象的一个属性存在</p>
<pre><code>btn.onclick = function() {
 var event = window.event;
 alert(event.type)   //click
}
使用event.srcElement来访问事件的目标(与target相同)
event.cancelBubble = false   //组止冒泡(stopPrapagation()相同)
event.returnValue = false    //阻止默认事件(preventDefault()相同)
</code></pre></li>
</ol>

            </div>
          
           
            <div class="copyright">
                <div class="name">
                    <a>本文作者:</a>
                    <a>LuckyFBB</a>
                </div>
                <div class="link">
                    <a>本文链接:</a>
                    <a class="permalink" href="https://luckyfbb.github.io/2019/01/26/JS高级教程/">https://luckyfbb.github.io/2019/01/26/JS高级教程/</a>
                </div>
            </div>
            

          


</article>


<div class="more">

    <div class="prev">
   <a href="/2019/02/11/浮动/">  CSS中的流</a>
    </div>

<div></div>

    <div class="next">
    <a href="/2019/01/19/个推面经/"> 个推前端面试面经 </a>
    </div>
    
</div>

<div class="bdsharebuttonbox">
<!-- <a href="#" class="bds_weixin fa fa-weixin" data-cmd="weixin" title="分享到微信" style="color:#1cbd8f">
</a>
<a href="#" class="bds_tsina fa fa-weibo" data-cmd="tsina" title="分享到新浪微博" style="color:#ff6363">
</a>
<a href="#" class="bds_twi fa fa-twitter" data-cmd="twi" title="分享到Twitter" style="color:#00A7EB">
</a>
<a href="#" class="bds_fbook fa fa-facebook" data-cmd="fbook" title="分享到Facebook" style="color:#00A7EB">
</a>
</div> -->
<script>
window._bd_share_config={
    "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},
    "share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='../../../../../static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></div>
 
<!-- <div id="comments"></div>

<script>
    var gitment = new Gitment({
    id: "Sat Jan 26 2019 12:44:33 GMT+0800",
    owner: "LuckyFBB",
    repo: "LuckyFBB.github.io",
    oauth: {
      client_id:"8d83609a651e972e308d",
      client_secret: "37e40c89a47e957f654e86f71c5caaccad0774de",
    }
  })
  gitment.render('comments')
</script> -->
    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2019 blog by LuckyFBB
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>